wait、notify、notifyAll：
wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被在此唤醒；
notify()方法可以随机唤醒等待队列中等待同意共享资源的一个线程，并使该线程退出等待队列，进入可运行状态。notify（）方法仅通知一个线程；
notifyAll()方法可以使所有正在等待队列中等到同一共享资源的全部线程从等待状态退出，优先级最高的那个线程最先执行。

ThreadStatus：
                                  yield()
                                    |
new Thread()-->新建线程-->start()-->运行-->[suspend()/sleep()/wait()]-->暂停
       |                           运行<---------resume()<-------------暂停
       |                             |                                  |
       |                       stop()/run()结束                          |
       |                              |                                 |
       |--->stop()------------------>销毁----------------->stop()------>__



1)start()方法为新建线程分屏CPU资源，使其处于Runnable状态（可运行），这是一个准备运行状态，如果线程抢占到CPU资源，该线程就处于running状态；
2)run()方法直接可以使线程处于运行状态，而不用等待，向普通的方法一样去运行；
3)runnable状态和running状态可以互换，因为有可能运行状态中，线程资源被其他优先级高的线程抢占了cpu资源。有可能从running切换到Runnable状态
4)线程进入runnable：
    1.sleep()
    2.线程正在等待通知
    3.
5)blocked是阻塞的意思。IO操作被略过，被抢占。阻塞过后进入runnable等待线程重新分配资源。
    1.调用sleep方法，主动房费
    2.调用阻塞时IO方法
6)run方法结束，进入销毁阶段。

每隔锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。